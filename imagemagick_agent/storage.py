"""File storage management for web interface uploads."""

import uuid
from pathlib import Path
from typing import Optional, Dict, List
import shutil


class FileStorage:
    """Manages uploaded files for the web interface."""

    def __init__(self, upload_dir: str = "uploads"):
        """Initialize file storage.

        Args:
            upload_dir: Directory to store uploaded files
        """
        self.upload_dir = Path(upload_dir)
        self.upload_dir.mkdir(exist_ok=True)

        # Track uploaded files: {original_filename: server_path}
        self.uploaded_files: Dict[str, Path] = {}

        # Track output files generated by ImageMagick
        self.output_files: List[Path] = []

        # Track the current working image (for transformation chaining)
        self.current_working_image: Optional[Path] = None

        # Track the original uploaded image (for replacing in commands)
        self.original_upload: Optional[Path] = None

        # Track the last output (pending acceptance)
        self.pending_output: Optional[Path] = None

    def save_uploaded_file(self, file_path: str, original_name: Optional[str] = None) -> Path:
        """Save an uploaded file to the server.

        Args:
            file_path: Path to the temporary uploaded file
            original_name: Original filename (optional)

        Returns:
            Path where the file was saved on server
        """
        source = Path(file_path)

        if not source.exists():
            raise FileNotFoundError(f"Upload file not found: {file_path}")

        # Generate unique filename
        if original_name:
            extension = Path(original_name).suffix
            base_name = Path(original_name).stem
        else:
            extension = source.suffix
            base_name = source.stem

        # Create unique filename with UUID
        unique_name = f"{base_name}_{uuid.uuid4().hex[:8]}{extension}"
        destination = self.upload_dir / unique_name

        # Copy file to uploads directory
        shutil.copy2(source, destination)

        # Track the file
        self.uploaded_files[original_name or source.name] = destination

        # Set as current working image and original upload
        self.current_working_image = destination
        self.original_upload = destination
        self.pending_output = None

        return destination

    def get_file_path(self, filename: str) -> Optional[Path]:
        """Get the server path for an uploaded file.

        Args:
            filename: Original filename

        Returns:
            Server path if found, None otherwise
        """
        return self.uploaded_files.get(filename)

    def get_latest_upload(self) -> Optional[Path]:
        """Get the most recently uploaded file.

        Returns:
            Path to latest uploaded file, or None if no files
        """
        if not self.uploaded_files:
            return None
        return list(self.uploaded_files.values())[-1]

    def add_output_file(self, file_path: Path) -> None:
        """Track an output file generated by ImageMagick.

        Args:
            file_path: Path to the output file
        """
        if file_path.exists():
            self.output_files.append(file_path)

    def get_output_files(self) -> List[Path]:
        """Get all output files generated.

        Returns:
            List of output file paths
        """
        return [f for f in self.output_files if f.exists()]

    def clear_outputs(self) -> None:
        """Clear the list of output files (doesn't delete the files)."""
        self.output_files = []

    def get_current_working_image(self) -> Optional[Path]:
        """Get the current working image for transformations.

        Returns:
            Path to current working image, or None if no image
        """
        return self.current_working_image

    def set_pending_output(self, file_path: Path) -> None:
        """Set a file as the pending output (awaiting acceptance).

        Args:
            file_path: Path to the output file
        """
        self.pending_output = file_path

    def accept_output(self) -> None:
        """Accept the pending output as the new working image."""
        if self.pending_output and self.pending_output.exists():
            self.current_working_image = self.pending_output
            self.pending_output = None

    def has_pending_output(self) -> bool:
        """Check if there's a pending output awaiting acceptance.

        Returns:
            True if there's a pending output, False otherwise
        """
        return self.pending_output is not None

    def cleanup(self) -> None:
        """Clean up all uploaded and output files."""
        # Delete uploaded files
        for file_path in self.uploaded_files.values():
            if file_path.exists():
                file_path.unlink()

        # Delete output files
        for file_path in self.output_files:
            if file_path.exists():
                file_path.unlink()

        # Clear tracking
        self.uploaded_files = {}
        self.output_files = []

    def reset(self) -> None:
        """Reset storage for a new session (clears tracking but keeps files)."""
        self.uploaded_files = {}
        self.output_files = []
        self.current_working_image = None
        self.original_upload = None
        self.pending_output = None
