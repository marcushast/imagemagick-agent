"""
Specialized logger for LLM API calls.

This module provides structured logging for LLM interactions including:
- Request logging with full context
- Response logging with timing and token usage
- Request/response correlation via request IDs
"""

import json
import logging
import time
import uuid
from datetime import datetime
from typing import Any, Dict, List, Optional


class LLMCallLogger:
    """
    Specialized logger for LLM API calls with structured JSON output.

    Logs are written in JSON Lines format for easy parsing and analysis.
    Each request/response pair is correlated via a unique request_id.
    """

    def __init__(self, enabled: bool = True):
        """
        Initialize LLM call logger.

        Args:
            enabled: Whether logging is enabled
        """
        self.enabled = enabled
        self.logger = logging.getLogger("llm_calls")

    def log_request(
        self,
        provider: str,
        model: str,
        user_input: str,
        conversation_history: List[Dict[str, str]],
        system_prompt: str,
        request_id: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None,
        session_id: Optional[str] = None,
    ) -> str:
        """
        Log an LLM API request.

        Args:
            provider: LLM provider name (anthropic, openai, google)
            model: Model identifier
            user_input: User's input message
            conversation_history: Previous conversation messages
            system_prompt: System prompt used for the request
            request_id: Optional request ID for correlation (generated if not provided)
            metadata: Optional additional metadata to log
            session_id: Optional session ID for tracking

        Returns:
            Request ID for correlating with response
        """
        if not self.enabled:
            return request_id or f"req_{uuid.uuid4().hex[:8]}"

        request_id = request_id or f"req_{uuid.uuid4().hex[:8]}"

        log_entry = {
            "timestamp": datetime.utcnow().isoformat() + "Z",
            "event": "llm_request",
            "request_id": request_id,
            "provider": provider,
            "model": model,
            "user_input": user_input,
            "conversation_history": conversation_history,
            "conversation_length": len(conversation_history),
            "system_prompt": system_prompt,
            "session_id": session_id,
        }

        if metadata:
            log_entry["metadata"] = metadata

        self._write_json(log_entry)
        return request_id

    def log_response(
        self,
        request_id: str,
        generated_command: str,
        response_time_ms: float,
        token_usage: Optional[Dict[str, int]] = None,
        error: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None,
        session_id: Optional[str] = None,
    ) -> None:
        """
        Log an LLM API response.

        Args:
            request_id: Request ID from log_request for correlation
            generated_command: Command generated by the LLM
            response_time_ms: Response time in milliseconds
            token_usage: Token usage statistics (input_tokens, output_tokens)
            error: Error message if request failed
            metadata: Optional additional metadata to log
            session_id: Optional session ID for tracking
        """
        if not self.enabled:
            return

        log_entry = {
            "timestamp": datetime.utcnow().isoformat() + "Z",
            "event": "llm_response",
            "request_id": request_id,
            "generated_command": generated_command,
            "response_time_ms": round(response_time_ms, 2),
            "token_usage": token_usage or {},
            "error": error,
            "success": error is None,
            "session_id": session_id,
        }

        if metadata:
            log_entry["metadata"] = metadata

        self._write_json(log_entry)

    def log_clarification(
        self,
        request_id: str,
        clarification_message: str,
        user_input: str,
    ) -> None:
        """
        Log when LLM requests clarification instead of generating a command.

        Args:
            request_id: Request ID from log_request for correlation
            clarification_message: Clarification message from LLM
            user_input: Original user input that needed clarification
        """
        if not self.enabled:
            return

        log_entry = {
            "timestamp": datetime.utcnow().isoformat() + "Z",
            "event": "llm_clarification",
            "request_id": request_id,
            "clarification_message": clarification_message,
            "user_input": user_input,
        }

        self._write_json(log_entry)

    def _write_json(self, data: Dict[str, Any]) -> None:
        """
        Write a JSON object as a single line to the log file.

        Args:
            data: Dictionary to write as JSON
        """
        try:
            json_line = json.dumps(data, ensure_ascii=False)
            self.logger.debug(json_line)
        except Exception as e:
            # Fallback logging if JSON serialization fails
            app_logger = logging.getLogger("imagemagick_agent")
            app_logger.error(f"Failed to write LLM log: {e}")


class ExecutionLogger:
    """
    Logger for ImageMagick command execution audit trail.

    Logs validation results and execution outcomes in structured format.
    """

    def __init__(self, enabled: bool = True):
        """
        Initialize execution logger.

        Args:
            enabled: Whether logging is enabled
        """
        self.enabled = enabled
        self.logger = logging.getLogger("executions")

    def log_validation(
        self,
        command: str,
        validation_result: bool,
        checks: Dict[str, bool],
        error_message: Optional[str] = None,
        session_id: Optional[str] = None,
    ) -> None:
        """
        Log command validation results.

        Args:
            command: Command that was validated
            validation_result: Whether validation passed
            checks: Dictionary of individual check results
            error_message: Error message if validation failed
            session_id: Optional session ID for tracking
        """
        if not self.enabled:
            return

        log_entry = {
            "timestamp": datetime.utcnow().isoformat() + "Z",
            "event": "command_validation",
            "command": command,
            "validation_result": "passed" if validation_result else "failed",
            "checks": checks,
            "error_message": error_message,
            "session_id": session_id,
        }

        self._write_json(log_entry)

    def log_execution(
        self,
        command: str,
        success: bool,
        execution_time_ms: float,
        output_file: Optional[str] = None,
        stdout: str = "",
        stderr: str = "",
        error_message: Optional[str] = None,
        session_id: Optional[str] = None,
    ) -> None:
        """
        Log command execution results.

        Args:
            command: Command that was executed
            success: Whether execution succeeded
            execution_time_ms: Execution time in milliseconds
            output_file: Path to output file if created
            stdout: Standard output from command
            stderr: Standard error from command
            error_message: Error message if execution failed
            session_id: Optional session ID for tracking
        """
        if not self.enabled:
            return

        log_entry = {
            "timestamp": datetime.utcnow().isoformat() + "Z",
            "event": "command_execution",
            "command": command,
            "success": success,
            "execution_time_ms": round(execution_time_ms, 2),
            "output_file": output_file,
            "stdout": stdout[:500] if stdout else "",  # Truncate long output
            "stderr": stderr[:500] if stderr else "",
            "error_message": error_message,
            "session_id": session_id,
        }

        self._write_json(log_entry)

    def log_user_action(
        self,
        action: str,
        command: str,
        auto_execute: bool,
    ) -> None:
        """
        Log user actions (confirmation, rejection).

        Args:
            action: Action taken (confirmed, rejected, auto_executed)
            command: Command that action was taken on
            auto_execute: Whether auto-execute mode was enabled
        """
        if not self.enabled:
            return

        log_entry = {
            "timestamp": datetime.utcnow().isoformat() + "Z",
            "event": "user_action",
            "action": action,
            "command": command,
            "auto_execute": auto_execute,
        }

        self._write_json(log_entry)

    def log_feedback(
        self,
        command: str,
        feedback: str,
        message_index: Optional[int] = None,
        output_file: Optional[str] = None,
        session_id: Optional[str] = None,
    ) -> None:
        """
        Log user feedback on command execution.

        Args:
            command: Command that feedback is for
            feedback: Feedback type ('liked' or 'disliked')
            message_index: Index of the message in chat history
            output_file: Output file associated with the command
            session_id: Optional session ID for tracking
        """
        if not self.enabled:
            return

        log_entry = {
            "timestamp": datetime.utcnow().isoformat() + "Z",
            "event": "user_feedback",
            "command": command,
            "feedback": feedback,
            "message_index": message_index,
            "output_file": output_file,
            "session_id": session_id,
        }

        self._write_json(log_entry)

    def _write_json(self, data: Dict[str, Any]) -> None:
        """
        Write a JSON object as a single line to the log file.

        Args:
            data: Dictionary to write as JSON
        """
        try:
            json_line = json.dumps(data, ensure_ascii=False)
            self.logger.debug(json_line)
        except Exception as e:
            app_logger = logging.getLogger("imagemagick_agent")
            app_logger.error(f"Failed to write execution log: {e}")
